"""
**********************************************************************

  A RapydScript to JavaScript compiler.
  https://github.com/atsepkov/RapydScript

  -------------------------------- (C) ---------------------------------

                       Author: Alexander Tsepkov
                         <atsepkov@pyjeon.com>
                         http://www.pyjeon.com

  Distributed under BSD license:
    Copyright 2016 (c) Alexander Tsepkov <atsepkov@pyjeon.com>

**********************************************************************
"""


# ------- UTILITY FUNCTIONS ----------

# sorting helper
def byType(a, b):
    # TODO: consider removing this when arrays are replaced by sets in ES6
    if a.type < b.type: return -1
    if a.type > b.type: return 1
    return 0

def normalize(arg):
    if not arg:
        raise Error()
    # normalizes the passed in argument into a compatible variable type
    if type(arg) is 'String':
        return { type: arg }        # variable or function with unknown signature
    elif type(arg) is 'Object' and arg.type:
        if arg.inputs:
            # convert each argument
            arg.inputs = [normalize(x) for x in arg.inputs]
        if arg.returns:
            # each return statement signature (there could be more than one return type if there are multiple return statements)
            arg.returns = [normalize(x) for x in arg.returns].sort(byType)
        return arg                  # function with known signature
    raise Error('Unexpected type passed into variable declaration: ' + type(arg) + ', expected types: String or Object')

def stringifySignature(varType):
    # convert element signature to printable version
    element = type(varType) is 'String' ? normalize(varType) : varType
    if element.type is 'Function' and element.inputs:
        signature = 'Function(' + [stringifySignature(arg) for arg in element.inputs].join(', ') + ')'
        if element.returns:
            returns = [stringifySignature(arg) for arg in element.returns].join(' or ')
            signature += ' -> ' + (element.returns.length > 1 ? '(' + returns + ')' : returns)
        return signature
    return element.type


'''
challenges:
    [x] non-typed function within typed (not allowed?)
        nonlocal typing enforced (variable enforcement is based on scope)
    [] are conditional types allowed? great for inputs / templates, incompatible with one-time types
        perhaps single-assignment conditional? except None
    [x] one-time types: can't change type after assignment, more harm or good?
        no, it is good, limit it to typed functions
    [] type annotations on assignment? interfaces? interface definitions?
        interface allows removal and easier declaration of variables
        implements interface? @interface?
    [] non-typed tracking:
        tracking through conditionals
        tracking WHERE (link back to node?)
            Assignment Node
            Reference Node
    [x] disable variable tracking via JS(), JS('a = a')
    [X] interface annotation / class annotation
        stuff:Number
        item:Number or String
        cls:MyClass = MyClass()
        ifc:Interface = { foo: 1, bar: 3 }

need:
    reference counter
    type tracker
    reassignment tracker?
'''

class Var:
    """
    tracks type, perhaps value too in the future, and number of references
    type can be simple or complex (functions)
    """
    def __init__(self, varType):
        self.type = varType
        self.properties = []

#    @staticmethod
#    def normalize(arg):
#        # normalizes the passed in argument into a compatible variable type
#        if type(arg) is 'String':
#            return Var(arg)        # variable or function with unknown signature
#        elif type(arg) is 'Object' and arg.type is 'Function':
#            if arg.inputs:
#                # convert each argument
#                arg.inputs = [Var.normalize(x) for x in arg.inputs]
#            if arg.returns:
#                # each return statement signature (there could be more than one return type if there are multiple return statements)
#                arg.returns = [Var.normalize(x) for x in arg.returns]
#            return arg                  # function with known signature
#        raise Error('Unknown argument type passed into variable declaration')

class Func(Var):
    '''
    handles functions
    '''
    def __init__(self, inputs=[], returns=[]):
        # inputs and returns should themselves be Var types
        Var.__init__(self, 'Function')
        self.inputs = inputs.map(def(arg):
            if type(arg) is 'String':
                if arg is 'Function':
                    return Func()       # function with unknown signature
                else:
                    return Var(arg)     # variable
            elif type(arg) is 'Object':
                return Func(arg)        # function with known signature
            raise Error('Unknown argument type passed into function declaration')
        )
        self.returns = returns

class Class(Var):
    '''
    handles class declaration
    '''
    def __init__(self, inputs):
        pass


class Timeline:
    '''
    A variable timeline which includes references to it, as well as declarations and reassignments. This timeline includes 3 major types:

    Basic variable, at its core this is the basis for the other 2, a function is just a variable generator and a class is a variable
    with more detail:
        {
            type: '?'           - variable type
            parent: { type },   - reference to parent
            properties: []      - properties attached to this variable (this list will grow)
        }

    Function with signature (inputs and results are arrays of other variables):
        {
            type: 'Function',
            properties: []      - properties attached to this function
            inputs: [],         - function inputs
            returns: []         - function outputs
        }

    Class with signature (note that class differs from variable in that class is a factory for a variable of the same type):
    i.e. a = Class, b = Class() -> a is a class, b is a variable (instance of class)
        {
            type: 'Class',
            properties: []      - class properties and static methods
            inputs: [],         - constructor signature
            returns: [],        - instance signature (array for consistency, length should always be one)
        }

    On assignment, multiple variables/properties can be linked to the same timeline, for omnipotent checks we will need to pass
    through the code at least twice (first time to populate the timeline, second time to analyze all possible states - especially
    important for properties). Perhaps we can just revisit properties directly, if we have pointers to them.
    '''

    def __init__(self, name, initialType=None, enforced=None):
        self.name = name                                # original name for this variable
        self.references = 0                             # number of references to this variable
        if enforced:
            self.enforced = []                          # array of types to enforce (variable has to be one of them)
            for element in enforced:
                self.enforced.push(normalize(element))
        self.timeline = []                              # TODO: change to Set in ES6
        self.properties = {}                            # properties existing on this variable
        if initialType:
            # even if initalType is not an object, these first 2 lines don't hurt, and do a better job normalizing
            # the hash than special-case handlers
            properties = initialType.properties
            del initialType.properties
            if properties:
                # create a separate timeline for each property
                for prop in properties:
                    self.properties[prop] = Timeline(self.name + '.' + prop, properties[prop])
            self.setVar(initialType)

    def setVar(self, arg):
        # sets this variable, for now only type is settable, perhaps value in the future as well
        variable = normalize(arg)
        if self.enforced:
            # strict settings, make sure variable type matches
            found = False
            for varType in self.enforced:
                if varType == variable:
                    found = True
                    break
            if not found:
                # handle unexpected type assignment
                expectedTypes = [stringifySignature(elem) for elem in self.enforced].join(' or ')
                raise Error("Can't assign value of type " + stringifySignature(variable) + " to '" + self.name + "', allowed type: " + expectedTypes)
        else:
            # lax variable settings, just push it to the list, but only if it's unique
            # TODO: change to sets in ES6
            for existing in self.timeline:
                if variable == existing: return
            self.timeline.push(variable)

    def setProperty(self, prop, arg):
        # sets property of this variable to a given type, since we can't really tell which type this property refers to, we'll assign it
        # to the global timeline object
        variable = normalize(arg)
        if prop in self.properties:
            self.properties[prop].setVar(variable)
            # even if initalType is not an object, these first 2 lines don't hurt, and do a better job normalizing
            # the hash than special-case handlers
        else:
            self.properties[prop] = Timeline(prop, variable)

    def addRef(self):
        # adds a reference to this variable
        self.references += 1

    def addCall(self, callSignature, alias=self.name):
        # logs a call into our state tracker and returns the call's return signature
        self.references += 1
        callSignature.inputs = [normalize(x) for x in callSignature.inputs]
        if self.enforced:
            signatureList = self.enforced
        else:
            signatureList = self.timeline
        callable = False
        found = []  # if length is 1, we have 1 function call that satisfies the requirement
        for expectedSignature in signatureList:
            matches = False
            if expectedSignature.type in ['Function', 'Class']:
                print(expectedSignature, callSignature)
                callable = True
                if expectedSignature.inputs:
                    # compare input types against expected types
                    if callSignature.inputs == expectedSignature.inputs:
                        matches = True
                else:
                    # no point in continuing, vague function definition means every call signature is allowed
                    matches = True

                if not matches: continue

                # TODO: change to Set in ES6
                if expectedSignature.returns:
                    for newReturn in expectedSignature.returns:
                        exists = False
                        if newReturn.type is '?':
                            # give up, vague definition, tell the caller that the return can be anything
                            return { type: '?' }
                        for existingReturn in found:
                            if newReturn == existingReturn:
                                exists = True
                                break
                        if not exists:
                            found.push(newReturn)
                else:
                    # the return can be anything
                    found = [{
                        type: '?'
                    }]
                    break

        if not callable:
            raise Error("'" + alias + "' is not a callable object")
        elif not found.length:
            # no valid signature found for this function call
            allowedFunctions = [stringifySignature(elem) for elem in signatureList if elem.type is 'Function'].join(' or ')
            if not callSignature.type: callSignature.type = 'Function'  # allows correct stringification
            raise Error("Can't call function " + alias + " with signature " + stringifySignature(callSignature) + ", allowed signatures: " + allowedFunctions)
        return found

    def getSignature(self):
        # returns the signature for this object
        # note that you're better off letting this system handle comparisons and manipulation of signatures than doing it yourself
        if self.enforced:
            # return all allowed types if this variable is strict about its types
            return self.enforced
        else:
            # return everything this variable has been at one time or another if it's not strict
            # TODO: replace this N^2 operation with a Set in ES6
            return self.timeline
#            return self.timeline.reduce(def(elements, element):
#                for varType in self.timeline:
#                    exists = False
#                    if varType == element:
#                        exists = True
#                    if not exists:
#                        elements.push(element)
#                return elements
#            , [])

    def getProperty(self, *props):
        # takes a chained list of properties and returns the relevant timeline
        # i.e. to get foo.a.b.c['d'], call foo.getProperty('a', 'b', 'c', 'd')
        timeline = self.properties
        for prop in props:
            timeline = timeline[prop]
            if not timeline:
                # property may be coming from outside, give up trying to make sense of it
                # we also can't raise an error for the same reason, but a linter could warn about it
                return None
        return prop

    def canUseFor(self, expectedType):
        # returns true if the variable matches one of expected types, false otheriwse
        # note that this will not check function/class signature
        expectedType = normalize(expectedType)
        vars = self.getSignature()

        for possibleType in vars:
            # inheritance resolution
            while possibleType:
                if possibleType.type is expectedType.type:
                    return True
                possibleType = possibleType.parent
        return False

    def canAlwaysUseFor(self, expectedType):
        # a stricter version of canUseFor, will only return true if compatible type can always be ensured
        if self.getSignature().length == 1 and self.canUseFor(expectedType):
            return True
        return False


class State:
    def __init__(self):
        self.scopes = [{
            type: 'global',     # scope type
            vars: {},           # variables in this scope
            functions: {},      # list of functions declared in this scope and their signatures
            classes: {},        # classes in this scope
            nonlocal: {},       # variables shared with outer scope
        }]
        self.functionScope = -1 # inner-most function scope
        self.classScope = -1    # inner-most class scope

    def newScope(self, scopeType, name=None, annotation=None):
        # starts a new scope
        self.scopes.push({
            type: scopeType,    # type of scope (class/function)
            name: name,         # name of this class/function
            vars: {},           # variables in this scope
            functions: {},      # list of functions declared in this scope and their signatures
            classes: {},        # classes in this scope
            nonlocal: {},       # variables shared with outer scope
        })
        if scopeType is 'class':
            self.classScope = self.scopes.length - 1
        elif scopeType is 'function':
            scope = self.scopes[-1]
            if annotation:
                annotation.type = 'Function'
                scope.annotation = normalize(annotation)
            scope.seenReturns = []
            self.functionScope = self.scopes.length - 1

    def endScope(self):
        # closes the top-most scope, returns the scope and adds function/class signature to parent scope
        top = self.scopes.pop()
        if top.type is 'function':
            for index, scope in enumerate(reversed(self.scopes)):
                if scope.type is 'function': self.functionScope = index
        elif top.type is 'class':
            for index, scope in enumerate(reversed(self.scopes)):
                if scope.type is 'class': self.classScope = index

        if top.type is 'function':
            if top.annotation and top.annotation.returns != top.seenReturns:
                raise Error(
                    "Annotation states that function returns " +
                    [stringifySignature(x) for x in top.annotation.returns].join(' or ') +
                    ", actual return types observed: " + ([stringifySignature(x) for x in top.seenReturns].join(' or ') or 'Undefined')
                )
            if top.name:
                if top.annotation:
                    # annotation is specified, use exactly that
                    self.scopes[-1].functions[top.name] = Timeline(top.name, top.annotation)
                else:
                    # no annotation is specified, use the signature we observed
                    self.scopes[-1].functions[top.name] = Timeline(top.name, {
                        # TODO: count arguments being passed
                        type: 'Function',
                        returns: top.seenReturns
                    })
        elif top.type is 'class':
            # we're returning a class, which is effectively a function that generates the variable of the type
            # defined by class name
            self.scopes[-1].classes[top.name] = Timeline(top.name, {
                type: 'Class',
                properties: top.staticMethods,
#                inputs: 
                returns: [{
                    type: top.name,
#                    properties: top.functions,
                    parent: top.parent and top.parent.returns ? top.parent.returns[0] : None
                }]
            })
        # NOTE: we do not handle imports here due to the number of available import systems, I may add some logic for it
        # in the future, or let the user handle it manually, they should be able to since they have access to the entire
        # popped scope object

        return top

    def setParent(self, name):
        # set parent of current class scope
        scope = self.scopes[self.classScope]
        parent = self.getSignature(name)[0]
        # more graceful handling of 3rd party inheritance
        if parent.type is '?':
            parent.type = 'Class'
            parent.returns = [{
                type: name,
                external: True
            }]
            parent.external = True
        scope.parent = parent

    def canUseFor(self, name, varType):
        # returns true if this timeline can be used to satisfy function signature requiring varType
        return self.getTimeline(name).canUseFor(varType)

    def canAlwaysUseFor(self, name, varType):
        # returns true if this timeline can be used to satisfy function signature requiring varType
        return self.getTimeline(name).canAlwaysUseFor(varType)

    def setVar(self, name, varType):
        # updates the variable in relevant scope
        # NOTE: if array is passed in, assume a conditional variable type
        timeline = self.getTimeline(name)
        if timeline:
            # update of existing variable
            timeline.setVar(varType)
        else:
            # new declaration
            # make sure to assign to top-most class or function scope
            self.scopes[Math.max(self.classScope, self.functionScope)].vars[name] = Timeline(name, varType)

    def setReturn(self, varType):
        # document a return for current scope
        actual = normalize(varType)
        scope = self.scopes[self.functionScope]
        if scope.annotation and scope.annotation.returns:
            for expected in scope.annotation.returns:
                if expected == actual:
                    # TODO: replace with ES6 sets
                    for seen in scope.seenReturns:
                        if actual == seen:
                            return  # duplicate
                    scope.seenReturns.push(actual)
                    return  # this is a valid return, we're all set with our safety check
            raise Error(
                "Annotation states that function returns " +
                [stringifySignature(x) for x in scope.annotation.returns].join(' or ') +
                ", actual return type: " + stringifySignature(actual)
            )
        else:
            # annotation not specified, every return is valid, but let's document it just for sanity
            # TODO: replace with ES6 sets
            for seen in scope.seenReturns:
                if actual == seen:
                    return  # duplicate
            scope.seenReturns.push(actual)

    def addRef(self, name):
        # add variable use reference (in this case we don't care if it's a variable or a function call)
        timeline = self.getTimeline(name)
        if timeline: timeline.addRef()
        # if it's not found, this could be a variable from outside library or global
        return timeline

    def addCall(self, signature):
        # add function call, this time we check if the annotation matches
        timeline = self.getTimeline(name)
        if timeline: timeline.addCall(signature)
        # if it's not found, this could be a function from outside library or global

    def getSignature(self, name):
        # return a list of all types this variable can be
        timeline = self.getTimeline(name)
        if timeline:
            return timeline.getSignature()
        else:
            return [{
                type: '?'
            }]

    def getTimeline(self, name):
        # obtains the underlying timeline for more direct manipulation
        timeline = None
        index = self.scopes.length - 1
        while not timeline and index >= 0:
            if name in self.scopes[index].vars:
                timeline = self.scopes[index].vars[name]
            elif name in self.scopes[index].functions:
                timeline = self.scopes[index].functions[name]
            elif name in self.scopes[index].classes:
                timeline = self.scopes[index].classes[name]
#            elif name in self.scopes[index].nonlocal:
#                index -= 1
            else:
                index -= 1
        return timeline
