"""
**********************************************************************

  A RapydScript to JavaScript compiler.
  https://github.com/atsepkov/RapydScript

  -------------------------------- (C) ---------------------------------

                       Author: Alexander Tsepkov
                         <atsepkov@pyjeon.com>
                         http://www.pyjeon.com

  Distributed under BSD license:
    Copyright 2016 (c) Alexander Tsepkov <atsepkov@pyjeon.com>

**********************************************************************
"""


# ------- UTILITY FUNCTIONS ----------
_warning = None
_error = None

# sorting helper
def byType(a, b):
    # TODO: consider removing this when arrays are replaced by sets in ES6
    if a.type < b.type: return -1
    if a.type > b.type: return 1
    return 0

def normalize(arg):
    if not arg:
        self.error("No argument specified")
    # normalizes the passed in argument into a compatible variable type
    if type(arg) is 'String':
        return { type: arg }        # variable or function with unknown signature
    elif type(arg) is 'Object':
        if not arg.type:
            arg.type = '?'
        if arg.inputs:
            # convert each argument
            arg.inputs = [normalize(x) for x in arg.inputs]
        if arg.returns:
            # each return statement signature (there could be more than one return type if there are multiple return statements)
            arg.returns = [normalize(x) for x in arg.returns].sort(byType)
        return arg                  # function with known signature
    self.error('Unexpected type passed into variable declaration: ' + type(arg) + ', expected types: String or Object')

def stringifySignature(varType):
    # convert element signature to printable version
    element = type(varType) is 'String' ? normalize(varType) : varType
    if (element.type is 'Function' or not element.type) and element.inputs:
        signature = 'Function(' + [stringifySignature(arg) for arg in element.inputs].join(', ') + ')'
        if element.returns:
            returns = [stringifySignature(arg) for arg in element.returns].join(' or ')
            signature += ' -> ' + (element.returns.length > 1 ? '(' + returns + ')' : returns or 'Undefined')
        return signature
    elementType = element.type or '?'
    return element.name ? element.name + ':' + elementType : elementType


'''
challenges:
    [x] non-typed function within typed (not allowed?)
        nonlocal typing enforced (variable enforcement is based on scope)
    [] are conditional types allowed? great for inputs / templates, incompatible with one-time types
        perhaps single-assignment conditional? except None
    [x] one-time types: can't change type after assignment, more harm or good?
        no, it is good, limit it to typed functions
    [] type annotations on assignment? interfaces? interface definitions?
        interface allows removal and easier declaration of variables
        implements interface? @interface?
    [] non-typed tracking:
        tracking through conditionals
        tracking WHERE (link back to node?)
            Assignment Node
            Reference Node
    [x] disable variable tracking via JS(), JS('a = a')
    [X] interface annotation / class annotation
        stuff:Number
        item:Number or String
        cls:MyClass = MyClass()
        ifc:Interface = { foo: 1, bar: 3 }

need:
    reference counter
    type tracker
    reassignment tracker?
'''

class Var:
    """
    tracks type, perhaps value too in the future, and number of references
    type can be simple or complex (functions)
    """
    def __init__(self, varType):
        self.type = varType
        self.properties = []

#    @staticmethod
#    def normalize(arg):
#        # normalizes the passed in argument into a compatible variable type
#        if type(arg) is 'String':
#            return Var(arg)        # variable or function with unknown signature
#        elif type(arg) is 'Object' and arg.type is 'Function':
#            if arg.inputs:
#                # convert each argument
#                arg.inputs = [Var.normalize(x) for x in arg.inputs]
#            if arg.returns:
#                # each return statement signature (there could be more than one return type if there are multiple return statements)
#                arg.returns = [Var.normalize(x) for x in arg.returns]
#            return arg                  # function with known signature
#        self.error('Unknown argument type passed into variable declaration')

class Func(Var):
    '''
    handles functions
    '''
    def __init__(self, inputs=[], returns=[]):
        # inputs and returns should themselves be Var types
        Var.__init__(self, 'Function')
        self.inputs = inputs.map(def(arg):
            if type(arg) is 'String':
                if arg is 'Function':
                    return Func()       # function with unknown signature
                else:
                    return Var(arg)     # variable
            elif type(arg) is 'Object':
                return Func(arg)        # function with known signature
            self.error('Unknown argument type passed into function declaration')
        )
        self.returns = returns

class Class(Var):
    '''
    handles class declaration
    '''
    def __init__(self, inputs):
        pass


class Timeline:
    '''
    A variable timeline which includes references to it, as well as declarations and reassignments. This timeline includes 3 major types:

    Basic variable, at its core this is the basis for the other 2, a function is just a variable generator and a class is a variable
    with more detail:
        {
            type: '?'           - variable type
            parent: { type },   - reference to parent
            properties: []      - properties attached to this variable (this list will grow)
        }

    Function with signature (inputs and results are arrays of other variables):
        {
            type: 'Function',
            properties: []      - properties attached to this function
            inputs: [],         - function inputs
            returns: []         - function outputs
        }

    Class with signature (note that class differs from variable in that class is a factory for a variable of the same type):
    i.e. a = Class, b = Class() -> a is a class, b is a variable (instance of class)
        {
            type: 'Class',
            properties: []      - class properties and static methods
            inputs: [],         - constructor signature
            returns: [],        - instance signature (array for consistency, length should always be one)
        }

    On assignment, multiple variables/properties can be linked to the same timeline, for omnipotent checks we will need to pass
    through the code at least twice (first time to populate the timeline, second time to analyze all possible states - especially
    important for properties). Perhaps we can just revisit properties directly, if we have pointers to them.
    '''

    def __init__(self, name, initialType=None, enforced=None):
        self.name = name                                # original name for this variable
        self.references = 0                             # number of references to this variable
        if enforced:
            self.enforced = []                          # array of types to enforce (variable has to be one of them)
            for element in enforced:
                self.enforced.push(normalize(element))
        self.timeline = []                              # TODO: change to Set in ES6
        self.properties = {}                            # properties existing on this variable
        if initialType:
            # even if initalType is not an object, these first 2 lines don't hurt, and do a better job normalizing
            # the hash than special-case handlers
            properties = initialType.properties
            del initialType.properties
            if properties:
                # create a separate timeline for each property
                for prop in properties:
                    self.properties[prop] = Timeline(self.name + '.' + prop, properties[prop])
            self.setVar(initialType)
        self.delayedLogic = {
            'call': []
        }

    def setVar(self, arg):
        # sets this variable, for now only type is settable, perhaps value in the future as well
        variable = normalize(arg)
        if self.enforced:
            # strict settings, make sure variable type matches
            found = False
            for varType in self.enforced:
                if varType == variable:
                    found = True
                    break
            if not found:
                # handle unexpected type assignment
                expectedTypes = [stringifySignature(elem) for elem in self.enforced].join(' or ')
                self.error("Can't assign value of type " + stringifySignature(variable) + " to '" + self.name + "', allowed type: " + expectedTypes)
        else:
            # lax variable settings, just push it to the list, but only if it's unique
            # TODO: change to sets in ES6
            for existing in self.timeline:
                if variable == existing: return
            self.timeline.push(variable)

    def setProperty(self, prop, arg):
        # sets property of this variable to a given type, since we can't really tell which type this property refers to, we'll assign it
        # to the global timeline object
        variable = normalize(arg)
        if prop in self.properties:
            self.properties[prop].setVar(variable)
            # even if initalType is not an object, these first 2 lines don't hurt, and do a better job normalizing
            # the hash than special-case handlers
        else:
            self.properties[prop] = Timeline(prop, variable)

    def addRef(self):
        # adds a reference to this variable
        self.references += 1

    def alignInputs(self, inputs):
        '''
        for kwargs-based functions call this first to move inputs around into correct order based on
        detected function signature, possible returns are:
            same inputs array but with arguments in correct order
            None:   order couldn't be determined for some reason

        args have to be in the following format:
            {
                ?name: item
                data: anything you want (usually the AST node itself)
            }
        '''
        def byName(name):
            return def(element):
                return name is element.name
        if self.enforced:
            signatureList = self.enforced
        else:
            signatureList = self.timeline
        found = False  # if True, we have at least 1 function call that satisfies the requirement
        for expectedSignature in signatureList:
            if expectedSignature.type in ['Function', 'Class']:
                if expectedSignature.inputs:
                    argMisalignment = inputs.length - expectedSignature.inputs.length
                    if argMisalignment > 0 or argMisalignment < 0 and not expectedSignature.inputs[inputs.length].default:
                        # signature has to match number of arguments unless the missing arguments are optional
                        continue
                    outputs = Array(expectedSignature.inputs.length)
                    failed = False
                    namesStarted = False
                    for idx, input in enumerate(inputs):
                        if namesStarted and not input.name:
                            self.error("Non-keyword argument after keyword argument in function call to " + self.name + "().")
                        if input.name:
                            # named arguments started, resolve position
                            namesStarted = True
                            index = expectedSignature.inputs.findIndex(byName(input.name))
                            if index is -1:
                                # TODO: probably throw a warning here due to amibguity
                                failed = True
                                break # not the right signature, don't error yet because there may be a right one later
                            elif outputs[index]:
                                self.error("" + self.name + "() got multiple values for keyword argument '" + input.name + "'")
                            else:
                                # inject named argument into correct position
                                outputs[index] = input
                        else:
                            # named arguments didn't start yet, maintain same order
                            outputs[idx] = input
                    if not failed:
                        # found something that satisfies the signature perfectly, return it
                        found = True
                        return outputs
                else:
                    # we found something that satisfies the signature, but there isn't enough information to resolve arguments
                    # tentatively take credit for it but continue searching for better matches
                    found = True
                    continue
        # not found, but let addCall deal with it
        return None

    def addCall(self, inputs, alias=self.name):
        # logs a call into our state tracker and returns the call's return signature
        # inputs: array of timelines
        self.references += 1
        if self.enforced:
            signatureList = self.enforced
        else:
            signatureList = self.timeline
        callable = False
        found = False  # if True, we have at least 1 function call that satisfies the requirement
        returns = []
        for expectedSignature in signatureList:
            matches = False
            if expectedSignature.type in ['Function', 'Class']:
                callable = True
                if expectedSignature.inputs:
                    # compare input types against expected types
                    argMisalignment = inputs.inputs.length - expectedSignature.inputs.length
                    if argMisalignment > 0 or argMisalignment < 0 and not expectedSignature.inputs[inputs.inputs.length].default:
                        # signature has to match number of arguments unless the missing arguments are optional
                        continue
                    for index, timeline in enumerate(inputs.inputs):
                        if self.enforced:
                            if not timeline.canUseFor(expectedSignature.inputs[index]):
                                break
                        else:
                            if not timeline.canUseFor(expectedSignature.inputs[index]):
                                break
                        if index is inputs.inputs.length - 1:
                            matches = True
                            found = True
                else:
                    # no point in continuing, vague function definition means every call signature is allowed
                    found = True
                    matches = True

                if not matches: continue

                # TODO: change to Set in ES6
                if expectedSignature.returns:
                    for newReturn in expectedSignature.returns:
                        exists = False
                        if newReturn.type is '?':
                            # give up, vague definition, tell the caller that the return can be anything
                            return { type: '?' }
                        for existingReturn in returns:
                            if newReturn == existingReturn:
                                exists = True
                                break
                        if not exists:
                            returns.push(newReturn)
                else:
                    # the return can be anything
                    returns = [{
                        type: '?'
                    }]
                    break

        if not callable:
            self.error("'" + alias + "' is not a callable object")
        elif not found:
            # no valid signature found for this function call
            callSignature = [elem.stringify() for elem in inputs.inputs].join(', ')
#            allowedFunctions = [[stringifySignature(input) for input in elem.inputs].join(', ') for elem in signatureList if elem.type is 'Function'].join(' or ')
            allowedFunctions = [stringifySignature(elem) for elem in signatureList if elem.type is 'Function'].join(' or ')
            self.error("Can't call function " + alias + " with signature 'Function(" + callSignature + ")', allowed signatures: " + allowedFunctions)

        for command in self.delayedLogic['call']:
            command(inputs)
        return returns

    def onCall(self, function):
        # add logic to trigger later (i.e. delay checking the variable timeline until)
        self.delayedLogic['call'].push(function)

    def getSignature(self):
        # returns the signature for this object
        # note that you're better off letting this system handle comparisons and manipulation of signatures than doing it yourself
        if self.enforced:
            # return all allowed types if this variable is strict about its types
            return self.enforced
        else:
            # return everything this variable has been at one time or another if it's not strict
            # TODO: replace this N^2 operation with a Set in ES6
            return self.timeline

    def stringify(self):
        sig = self.getSignature()
        return [stringifySignature(x) for x in sig].join(' or ')

    def getProperty(self, *props):
        # takes a chained list of properties and returns the relevant timeline
        # i.e. to get foo.a.b.c['d'], call foo.getProperty('a', 'b', 'c', 'd')
        timeline = self.properties
        for prop in props:
            timeline = timeline[prop]
            if not timeline:
                # property may be coming from outside, give up trying to make sense of it
                # we also can't raise an error for the same reason, but a linter could warn about it
                return None
        return prop

    def canUseFor(self, expectedType):
        # returns true if the variable matches one of expected types, false otheriwse
        # note that this will not check function/class signature
        expectedType = normalize(expectedType)
        vars = self.getSignature()

        for possibleType in vars:
            # inheritance resolution
            while possibleType:
                if possibleType.type is expectedType.type or expectedType.type is '?':
                    return True
                possibleType = possibleType.parent
        return False

    def canAlwaysUseFor(self, expectedType):
        # a stricter version of canUseFor, will only return true if compatible type can always be ensured
        if self.getSignature().length == 1 and self.canUseFor(expectedType):
            return True
        return False

    # --- logic to delay execution until a later time ---

    def addDelayed(self, function):
        self.delayedLogic.push(function)

    def triggerDelayed(self):
        # triggers delayed logic
        for function in self.delayedLogic:
            function()

    # ----- ERROR HANDLERS ------
    def warning(self, message):
        if _warning:
            _warning(message)

    def error(self, message):
        if _error:
            _error(message)
        else:
            raise Error(message)


class State:
    def __init__(self):
        self.scopes = []
        self.newScope('global')
        self.functionScope = -1 # inner-most function scope
        self.classScope = -1    # inner-most class scope

    def newScope(self, scopeType, name=None, annotation=None):
        # starts a new scope
        self.scopes.push({
            type: scopeType,    # type of scope (class/function)
            name: name,         # name of this class/function
            vars: {},           # variables in this scope
            functions: {},      # list of functions declared in this scope and their signatures
            classes: {},        # classes in this scope
            nonlocal: {},       # variables shared with outer scope
            delayed: {
                'endScope': [], # list of functions to trigger when endScope is called
                'call': []      # list of functions to trigger when addCall is called on resulting timeline
            }
        })
        if scopeType is 'class':
            self.classScope = self.scopes.length - 1
        elif scopeType is 'function':
            scope = self.scopes[-1]
            if annotation:
                annotation.type = 'Function'
                scope.annotation = normalize(annotation)
            scope.seenReturns = []
            self.functionScope = self.scopes.length - 1
        elif scopeType in ['if', 'switch', 'try']:
            scope = self.scopes[-1]
            scope.states = [{}]     # each state will append a hash here, which will store variables that got set in that state
            scope.final = False     # once scope reaches its final state, this will be changed to true

    def nextScopeState(final=False):
        # transitions through scope states (i.e. if/else, try/catch)
        # final implies that this state will always be the last state (i.e. else rather than elif, default case for switch)
        scope = self.scopes[-1]
        scope.final = final

    def endScope(self):
        # closes the top-most scope, returns the scope and adds function/class signature to parent scope
        top = self.scopes.pop()
        if top.type is 'function':
            for index, scope in enumerate(reversed(self.scopes)):
                if scope.type is 'function':
                    self.functionScope = index
                    break
                elif scope.type is 'global':
                    self.functionScope = -1
                    break
        elif top.type is 'class':
            for index, scope in enumerate(reversed(self.scopes)):
                if scope.type is 'class':
                    self.classScope = index
                    break
                elif scope.type is 'global':
                    self.classScope = -1
                    break

        if top.type is 'function':
            if top.annotation and top.annotation.returns and top.annotation.returns != top.seenReturns:
                self.error(
                    "Annotation states that function returns " +
                    [stringifySignature(x) for x in top.annotation.returns].join(' or ') +
                    ", actual return types observed: " + ([stringifySignature(x) for x in top.seenReturns].join(' or ') or 'Undefined')
                )
            if top.name:
                # if function doesn't have a name, we can't reference it later
                if top.annotation:
                    # annotation is specified, use exactly that
                    inputs = []
                    for index, element in enumerate(top.annotation.inputs):
                        inputs.push(Object.assign({
                            name: top.args[index].name,
                            default: top.args[index].default
                        }, element))
                    declaration = {
                        type: 'Function',
                        inputs: inputs,
                        returns: top.annotation.returns
                    }
                else:
                    # no annotation is specified, use the signature we observed
                    declaration = {
                        type: 'Function',
                        returns: top.seenReturns
                    }
                    if top.args: declaration.inputs = top.args

                # sanity check to make sure we're not bastardizing polymorphism
                existingTimeline = self.getTimeline(top.name)
                if existingTimeline and declaration.inputs:
                    canUse = True
                    for function in existingTimeline.getSignature():
                        if function.type is 'Function':
                            for index, arg in enumerate(function.inputs):
                                if arg.name is not declaration.inputs[index].name or arg.type is not declaration.inputs[index].type:
                                    self.warning(
                                        "Redefining earlier declaration of " + top.name + "() with incompatbile signature: " +
                                        stringifySignature(declaration) + ", allowed signatures: " + existingTimeline.stringify()
                                    )
                                    canUse = False
                                    break
                        if not canUse: break

                timeline = self.scopes[-1].functions[top.name] = Timeline(top.name, declaration)
        elif top.type is 'class':
            # we're returning a class, which is effectively a function that generates the variable of the type
            # defined by class name
            timeline = self.scopes[-1].classes[top.name] = Timeline(top.name, {
                type: 'Class',
                properties: top.staticMethods,
#                inputs: 
                returns: [{
                    type: top.name,
#                    properties: top.functions,
                    parent: top.parent and top.parent.returns ? top.parent.returns[0] : None
                }]
            })
        elif top.states and top.final:
            # for every variable that appears in all scopes and has final scope, we replace existing timeline
            # we also set this variable on parent's scope if parent is stateful in order to gracefully handle
            # nested conditionals (we only need to worry about replace cases since add has already been handled)
            for var in top.states[0]:
                signature = [top.states[0][var]]
                for state in top.states[1:]:
                    if var in state:
                        signature.concat(var)
                    else:
                        break
                    if state is top.states[-1]:
                        if self.scopes[-1].states:
                            # TODO: do concat vs init, also make sure this is unique
                            self.scopes[-1].states[var] = signature
        # NOTE: we do not handle imports here due to the number of available import systems, I may add some logic for it
        # in the future, or let the user handle it manually, they should be able to since they have access to the entire
        # popped scope object

        if timeline:
            for command in top.delayed['call']:
                timeline.onCall(command)
        for command in top.delayed['endScope']:
            # trigger every delayed action and pass it scope in case it needs to do something with it, this is useful
            # for both handling imports as well as handling cases like self-referencing classes that may need the
            # entire class to be parsed before triggering the logic
            command(top)
        return top

    def setParent(self, name):
        # set parent of current class scope
        scope = self.scopes[self.classScope]
        parent = self.getSignature(name)[0]
        # more graceful handling of 3rd party inheritance
        if parent.type is '?':
            parent.type = 'Class'
            parent.returns = [{
                type: name,
                external: True
            }]
            parent.external = True
        scope.parent = parent

    def setArgs(self, args):
        '''
        arg format:
            {
                name: 'argname',
                ?default: 'value'
            }
        '''
        scope = self.scopes[self.functionScope]
        # TODO: change to existential operator
        if scope.args:
            # shouldn't really happen unless there is a bug in the compiler itself
            self.error("Redeclaration of arguments for " + self.name + "() is not allowed.")
        if scope.annotation and scope.annotation.inputs and scope.annotation.inputs.length is not args.length:
            # shouldn't really happen unless there is a bug in the compiler itself
            self.error("Specified arguments don't line up with function annotation.")
        defaultStarted = False
        for arg in args:
            if not arg.name:
                self.error("Invalid format for args in " + self.name + "() declaration, required format is an array of { name: 'string', ?default: ... }")
            if arg.default:
                defaultStarted = True
            else:
                # raise an error when seeing something like 'def func(a=5, b)'
                if defaultStarted: self.error("Missing default value for argument '" + arg.name + "' of function '" + scope.name + "'. Arguments with default values must come last in function declaration.")
        scope.args = args

    def canUseFor(self, name, varType):
        # returns true if this timeline can be used to satisfy function signature requiring varType
        return self.getTimeline(name).canUseFor(varType)

    def canAlwaysUseFor(self, name, varType):
        # returns true if this timeline can be used to satisfy function signature requiring varType
        return self.getTimeline(name).canAlwaysUseFor(varType)

    def markNonLocal(self, name):
        self.scopes[self.functionScope].nonlocal[name] = True

    def setVar(self, name, varType, enforced=None):
        # updates the variable in relevant scope
        # NOTE: if array is passed in, assume a conditional variable type
        timeline = self.getTimeline(name, True)
        if timeline:
            if enforced:
                # make sure no type violations in enforcement
                for var in enforced:
                    if not timeline.canUseFor(var):
                        self.error(
                            "Variable redeclaration (" + [stringifySignature(var) for var in enforced].join(' or ') +
                            ") for '" + name + "' conflicts with earlier format: " + timeline.stringify()
                        )
            # update of existing variable
            timeline.setVar(varType)
        else:
            # new declaration
            # make sure to assign to top-most class or function scope
            self.scopes[Math.max(0, self.classScope, self.functionScope)].vars[name] = Timeline(name, varType, enforced)

        if self.states:
            if name in self.states[-1]:
                self.states[-1][name].push(normalize(varType))
            else:
                self.states[-1][name] = [normalize(varType)]

    def setReturn(self, varType):
        # document a return for current scope
        actual = normalize(varType)
        scope = self.scopes[self.functionScope]
        if scope.annotation and scope.annotation.returns:
            for expected in scope.annotation.returns:
                if expected == actual:
                    # TODO: replace with ES6 sets
                    for seen in scope.seenReturns:
                        if actual == seen:
                            return  # duplicate
                    scope.seenReturns.push(actual)
                    return  # this is a valid return, we're all set with our safety check
            self.error(
                "Annotation states that function returns " +
                [stringifySignature(x) for x in scope.annotation.returns].join(' or ') +
                ", actual return type: " + stringifySignature(actual)
            )
        else:
            # annotation not specified, every return is valid, but let's document it just for sanity
            # TODO: replace with ES6 sets
            for seen in scope.seenReturns:
                if actual == seen:
                    return  # duplicate
            scope.seenReturns.push(actual)

    def addRef(self, name):
        # add variable use reference (in this case we don't care if it's a variable or a function call)
        timeline = self.getTimeline(name)
        if timeline: timeline.addRef()
        # if it's not found, this could be a variable from outside library or global
        return timeline

    def onEndScope(self, function):
        # performs the function after current scope terminates, this is useful for handling self-references
        # within classes, like reference to self.staticMethod()
        self.scopes[-1].delayed['endScope'].push(function)

    def onCall(self, function):
        self.scopes[-1].delayed['call'].push(function)

    def alignInputs(self, name, inputs):
        timeline = self.getTimeline(name)
        if timeline:
            return timeline.alignInputs(inputs)
        else:
            return None

    def addCall(self, name, signature):
        # add function call, this time we check if the annotation matches
        timeline = self.getTimeline(name)
        if timeline: timeline.addCall(signature)
        # if it's not found, this could be a function from outside library or global

    def getSignature(self, name):
        # return a list of all types this variable can be
        timeline = self.getTimeline(name)
        if timeline:
            return timeline.getSignature()
        else:
            return [{
                type: '?'
            }]

    def getTimeline(self, name, local=False):
        # obtains the underlying timeline for more direct manipulation
        # stayLocal will stay local unless the variable is already flagged as nonlocal
        timeline = None
        index = self.scopes.length - 1
        while not timeline and index >= 0:
            if name in self.scopes[index].vars:
                timeline = self.scopes[index].vars[name]
            elif name in self.scopes[index].functions:
                timeline = self.scopes[index].functions[name]
            elif name in self.scopes[index].classes:
                timeline = self.scopes[index].classes[name]
            elif not local or self.functionScope > 0 and name in self.scopes[self.functionScope].nonlocal:
                index -= 1
            else:
                # local is set, don't traverse outer scopes
                break
        return timeline

    # ----- ERROR HANDLERS ------
    def onWarning(self, callback):
        nonlocal _warning
        _warning = callback

    def warning(self, message):
        if _warning:
            _warning(message)

    def onError(self, callback):
        nonlocal _error
        _error = callback

    def error(self, message):
        if _error:
            _error(message)
        else:
            raise Error(message)
