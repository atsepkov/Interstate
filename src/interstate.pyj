###################################################
# WARNINGS:
#   stated types that are never assigned
#   binary/unary operation with unspecified type
# ERRORS:
#   assignment violates stated types
#   binary/unary operation on incompatible types
###################################################

# issues:
#   how do we represent hashes?
#   how deep inside do we go?
#   what about circular hashes?
#   what about intentionally circular hashes? i.e. tree nodes
#   when property throws an assignment error, it needs to be aware of its parent's name

def unique(val, index, self):
    return self.indexOf(val) is index

def suggestion(message, line='N/A'):
    console.log(f'SUGGESTION (${line}): ' + message)

def warning(message, line='N/A'):
    console.log(f'WARNING (${line}): ' + message)

def error(message, line='N/A'):
    console.error(f'ERROR (${line}): ' + message)

"""
Temporary test/debug wrapper
"""
def t(f):
    return def(t, i, l):
        # console.log("input >", i + f" ${t[i]}")
        output, i1 = f(t, i, l)
        # console.log("out >", i + f" ${t[i]}", i1 + f" ${t[i1]}")
        # console.log("output >", JSON.stringify(output, null, 2))
        # print('')
        return output, i1

def isWord(token):
    return /^[_A-Za-z][_A-Za-z0-9]*$/.test(token)

def _buildObjectLiteralNode(tokenList, index):
    node = {
        type: 'interface',
        content: {}
    }
    index += 1
    while True:
        if isWord(tokenList[index]) and tokenList[index+1] is ':':
            key = tokenList[index]
            value, index = buildSignatureNode(tokenList, index+2)
            node.content[key] = value
            if tokenList[index] is '}':
                break
            elif tokenList[index] is ',':
                index = index+1
            else:
                raise Error("Invalid implicit interface")
        else:
            raise Error("Invalid implicit interface")
    return node, index


def buildSignatureNode(tokenList, index=0, isList=False):
    if tokenList[index] is 'Function':
        args, index = t(buildSignatureNode)(tokenList, index+1)
        returns, index = t(buildSignatureNode)(tokenList, index+1, True)
        return {
            type: 'Function',
            args: args,
            rets: returns
        }, index
    elif tokenList[index] in ['(', '['] or isList:
        end = tokenList[index] is '[' ? ']' : tokenList[index] is '{' ? '}' : ')'
        # grouped logic or argument list
        content = isList and tokenList[index] not in ['(', '['] ? [tokenList[index]] : []
        while True:
            index += 1
            token = tokenList[index]
            if token is ',':
                # comma-separated list
                continue
                # index += 1
                # token = tokenList[index]
            elif token in ['(', '[']:
                # nested list or logic
                token, index = t(buildSignatureNode)(tokenList, index)
            elif token is '{':
                # implicit interface/hash
                token, index = _buildObjectLiteralNode(tokenList, index)
            elif token is '...':
                spread, index = t(buildSignatureNode)(tokenList, index+1)
                token = {
                    type: '...',
                    content: spread
                }
                index -= 1 # without this the outer loop won't see ending brace
            elif token in ['or', 'and']:
                if content.length is 1:
                    right, index = t(buildSignatureNode)(tokenList, index+1)
                    token = {
                        type: token,
                        left: content.pop(),
                        right: right
                    }
                else:
                    raise Error(f"Invalid type definition syntax on the left side of binary '${token}' operator.")
            elif token is end or token is ';':
                break
            elif token is undefined:
                if isList:
                    break
                else:
                    raise Error(f"Invalid type definition")
            elif token is '}':
                index -= 1 # roll back a bit for the outer hash to parse correctly
                break
            elif not isWord(token):
                raise Error(f"Invalid token '${token}' in list")
            content.push(token)
        returns = content.length > 1 ? {
            type: 'list',
            content: content
        } : content[0]
        if end is ']':
            returns = {
                type: 'array',
                content: returns
            }
        return returns, index+1
    elif tokenList[index] is '...':
        spread, index = t(buildSignatureNode)(tokenList, index+1)
        return {
            type: '...',
            content: spread
        }, index
    elif tokenList[index] is '{':
        return t(_buildObjectLiteralNode)(tokenList, index)
    elif tokenList[index] is '->':
        return t(buildSignatureNode)(tokenList, index+1)
    else:
        return tokenList[index], index+1


def parseSignature(signature, line):
    """
    Converts compact signature into JSON version used by the processor
    """
    chunks = signature.split(/\b/g)
    tokens = []
    _pushToken = def(token):
        if token not in ['...', '(', ')', '[', ']', '->', ',', ':', ';', '{', '}']:
            error(f"Invalid token: '${token}' in signature '${signature}'")
        else:
            tokens.push(token)

    for chunk in chunks:
        if chunk.trim():
            if chunk.toLowerCase() is not chunk.toUpperCase():
                # this is a word
                tokens.push(chunk)
            else:
                # set of special chars to parse
                buffer = ''
                for char in chunk:
                    if char in '-.':
                        buffer += char
                    else:
                        if char in ' ([{;' and buffer:
                            # push token prefixing parens
                            _pushToken(buffer)
                            if char is not ' ':
                                # push parens as a separate token
                                _pushToken(char)
                        elif char is not ' ':
                            # push combo token like ->
                            _pushToken(buffer + char)
                        buffer = ''

    # console.log(tokens)
    try:
        node = t(buildSignatureNode)(tokens)
        return JSON.stringify(node, null, 2)
    except as e:
        error(f"${e} for signature '${signature}'.", line)


class Variable:
    """
    Tracks timeline of a variable, types that have been seen assigned to it, and where the assignment occured

    Signature is always an array of types
    """
    def __init__(self, name, line, signature=None):
        self.name = name                    # variable name
        self.line = line                    # line of initial declaration/use
        self.signature = signature          # user-defined signature for this variable (strict enforcement)
        self.assignments = []               # assignment promises
        self.assignmentCounter = 0          # number of assignments seen
        self.done = Promise(def(resolve):
            self._endTimeline = resolve
        )
        self.typesSeen = {}         # types based on constants seen assigned to this variable
        self.typesInferred = {}     # types inferred based on other variables seen assigned to this variable

        self.propertyAssignments = {}       # properties seen assigned for this variable

    def set(self, typeOrVar, line):
        """
        Triggered on variable assignment, t can be a string (in which case type is resolved immediatelly)
        or another Variable class. Type resolution happens when all assigned variables terminate
        """

        self.assignmentCounter += 1
        if type(typeOrVar) is 'Variable':
            # variable assignment
            self.assignments = self.assignments.concat(typeOrVar.done.then(def(inheritedTypes):
                # once assigned variable timeline resolves, flatten all seen types from it
                types = []
                for t in inheritedTypes.types:
                    if self.signature and t not in self.signature:
                        types.push(t)
                if types.length:
                    error(
                        f'Assignment of variable "${inheritedTypes.name}" to "${self.name}" is not allowed because it takes on incompatible types (${types}), types allowed by signature: ${self.signature}',
                        line
                    )
                    self.typesInferred[t] = 1
                return inheritedTypes.types.concat(Object.keys(self.typesSeen)).filter(unique)
            ))
        else:
            # constant assignment
            if typeOrVar is 'Object' and state.findSignature(self.signature).type is 'interface':
                # make sure all required interface properties are assigned
                self.typesSeen[typeOrVar] = self.typesSeen[typeOrVar] + 1 or 1
            elif self.signature and typeOrVar not in self.signature:
                # throw error about incompatible assignment
                error(
                    f'Attempting to assign "${typeOrVar}" type to variable "${self.name}" on line ${line}, types allowed by signature: ${self.signature}',
                    line
                )
            else:
                # allow basic assignment
                self.typesSeen[typeOrVar] = self.typesSeen[typeOrVar] + 1 or 1

    def getProperty(self, prop):
        return self.propertyAssignments[prop]

    def setProperty(self, prop, typeOrVar, line):
        """
        set to a property of this variable.
        """
        propertySignature = None

        # we want to only allow assignment if it's valid by interface standards
        if self.signature:
            if self.signature.length is 1:
                # first, find the actual signature
                if type(self.signature[0]) is 'String':
                    # explicit interface
                    signature = state.findSignature(self.signature[0])
                else:
                    # implicit interface
                    signature = self.signature[0]

                if signature.type in ['interface', 'class']:
                    if prop not in signature.format:
                        # immediate interface does not contain this property, need to check parents
                        if signature.restricted:
                            error(
                                f"Variable '${self.name}' follows '${self.signature}' interface, which does not allow assignment to '${prop}' property",
                                line
                            )
                    else:
                        # immediate interface contains this property
                        propertySignature = [signature.format[prop]]
                else:
                    error(f"'${self.name}' is neither a class nor an interface, assignment to '${prop}' property is not allowed.", line)
            else:
                error(
                    f"Ambiguous assignment to property '${prop}' of variable '${self.name}', variable takes on multiple types: ${self.signature}.",
                    line
                )
        else:
            types = []
            for t in self.typesSeen:
                if t in stdlib.classes:
                    types.push(t)

            if types.length:
                error(
                    f"Assignment of '${prop}' property to variable '${self.name}' is not allowed because variable could take on the following types: ${types}.",
                    line
                )

        if not self.propertyAssignments[prop]:
            # initial assignment to this property
            self.propertyAssignments[prop] = Variable(f"${self.name}.${prop}", line, propertySignature)

        self.propertyAssignments[prop].set(typeOrVar, line)

    def terminate(self):
        """
        Triggered when variable timeline terminates, causing all variables that this variable was assigned to
        to update variable types seen assigned to them.
        """

        for prop in self.propertyAssignments:
            self.propertyAssignments[prop].terminate()

        Promise.all(self.assignments).then(def(types):
            types = types.reduce(def(acc, val): return acc.concat(val);, []) # flatten inherited types
            allTypes = {}
            for t in types:
                if self.signature and t not in self.signature:
                    # error(f'Variable assigned to "${self.name}" could be of type "${t}", types allowed by signature: ${self.signature}')
                    pass
                else:
                    allTypes[t] = 1
            for t in self.typesSeen:
                allTypes[t] = 1

            # tracker's code refactor suggestions to developer
            typeList = Object.keys(allTypes)
            if self.signature and self.signature.length > 2:
                suggestion(
                    f'Variable "${self.name}" signature states too many types (${self.signature}), consider separating into additional variables for clarity.',
                    self.line
                )
            elif typeList.length > 2:
                suggestion(
                    f'Variable "${self.name}" takes on too many types (${typeList}), consider separating into additional variables for clarity.', self.line,
                    self.line
                )
            if not self.signature and self.assignmentCounter > 1 and typeList.length is 1:
                suggestion(f'All assignments to variable "${self.name}" are of type "${typeList[0]}", consider specifing type."', self.line)

            for t in self.signature or []:
                if t not in allTypes:
                    warning(f'Variable "${self.name}" states a possible type of "${t}", but no such type is ever assigned.', self.line)
            self._endTimeline({
                name: self.name,
                types: Object.keys(allTypes),
                signature: self.signature
            })
        )


class StandardLib:
    def __init__(self):
        self.classes = { key : key for key in ['Number', 'String', 'Array', 'RegExp', 'Date', 'Object'] }

stdlib = StandardLib()


class Scope:
    """
    Tracks variables declared in this specific scope, interstate will nest scopes.
    """
    def __init__(self, name, line):
        self.name = name    # scope name
        self.line = line    # line number where declaration starts
        self.classes = {}   # user-declared classes
        self.variables = {} # variables declared in this scope
        self.interfaces = {}# interfaces declared in this scope

    def newClass(self, name, line, format, parents, interfaces, restricted):
        self.classes[name] = {
            type: 'class',
            format: format,
            parents: parents,
            interfaces: interfaces,
            restricted: restricted,
            scope: state.scopes.length-1,
            line: line
        }

    def newInterface(self, name, line, format, parents, restricted):
        # make sure it doesn't clobber an earlier generic or interface

        self.interfaces[name] = {
            type: 'interface',
            format: format,
            parents: parents,
            restricted: restricted,
            scope: state.scopes.length-1,
            line: line
        }


class State:
    """
    Tracks declared variables and rertieves the timeline for relevant one as needed. Also tracks declared types and generics.
    """
    def __init__(self):
        self.scopes = []    # stack of scopes
        self.generics = {}  # generic declarations seen in the code


    # scope control
    def newScope(self, name, line):
        self.scopes.push(Scope(name, line))

    def endScope(self, line):
        scope = self.scopes.pop()
        for var in scope.variables:
            scope.variables[var].terminate()


    def gatherProperties(self, interfaceName, startingScope=state.scopes.length-1):
        """
        Recursively traverses parents to gather properties that are part of this class/interface
        """
        properties = {}
        signature = self.findSignature(interfaceName, startingScope)
        for obj in signature.parents:
            parentProps = self.gatherProperties(obj, signature.scope)
            properties = Object.assign(properties, parentProps)

        return Object.assign(properties, signature.format)


    # operations within scope
    def newClass(self, name, line, format={}, parents=[], interfaces=[], restricted=False):
        if name in self.generics:
            error(f"Class declaration '${name}' redefines an earlier generic, if this is in fact the same class, move the declaration to the top.", line)
        else:
            if format:
                properties = {}
                newProperties = {}
                for parent in parents:
                    properties = Object.assign(properties, self.gatherProperties(parent))
                for prop in format:
                    possibleTypes = format[prop].sort()
                    newProperties[prop] = possibleTypes
                    if properties[prop] and properties[prop] != possibleTypes:
                        warning(f"Class declaration for '${name}' redefines the format of '${prop}' property declared by one of its parents.", line)
            self.scopes[-1].newClass(name, line, newProperties, parents, interfaces, restricted)

    def newInterface(self, name, line, format, parents=[], restricted=False):
        if name in self.generics:
            error(
                f"Interface declaration '${name}' redefines an earlier generic, if this is in fact the same interface, move the declaration to the top.",
                line
            )
        else:
            properties = {}
            newProperties = {}
            for parent in parents:
                properties = Object.assign(properties, self.gatherProperties(parent))
            for prop in format:
                possibleTypes = format[prop].sort()
                newProperties[prop] = possibleTypes
                if properties[prop] and properties[prop] != possibleTypes:
                    warning(f"Interface '${name}' redefines the format of '${prop}' property declared by one of its parents.", line)
            self.scopes[-1].newInterface(name, line, newProperties, parents, restricted)

    def newGeneric(self, name, line, inherits=None):
        self.generics[name] = {
            type: 'generic',
            superclass: inherits,
            scope: self.scopes.length-1,
            line: line # first use of this generic
        }

    def newVariable(self, name, line, signature=None, assignment=None):
        return self.scopes[-1].variables[name] = Variable(name, line, signature)

    def newReturn(self, var, line):
        """
        Document an explicit return in a function call, used for building implicit function signature and/or
        testing explicit function signature.
        """
        pass

    def findSignature(self, name, startingScope=state.scopes.length-1):
        """
        Find interface/class/variable by name, returns signature of the interface or None if undefined

        Takes string, returns node describing the inteface
        """

        # first, check if it's a basic type or part of JS standard library
        if name in stdlib.classes:
            return stdlib.classes[name]

        # now check for inner-most scope declaration
        for scope in self.scopes[startingScope::-1]:
            if name in scope.interfaces:
                return scope.interfaces[name]
            elif name in scope.classes:
                return scope.classes[name]
            elif name in scope.variables:
                return scope.variables[name]

        # now check generics
        if name in self.generics:
            return self.generics[name]

        return None

    def invoke(self, name, parameters):
        """
        Used for function calls, tests inputs and outputs, as well as handle timeline checks.
        """
        print(self.generics)
        sig = self.findSignature(name)
        print(parseSignature(sig.signature[0]))

state = State()


